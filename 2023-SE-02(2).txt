2023-SE-02
–ò–º–∞—Ç–µ —Ñ–∞–π–ª, —Å—ä–¥—ä—Ä–∂–∞—â –∞–Ω–≥–ª–∏–π—Å–∫–∏ —Ç—ä–ª–∫–æ–≤–µ–Ω —Ä–µ—á–Ω–∏–∫, –ø—Ä–µ–¥—Å—Ç–∞–≤–µ–Ω –≤—ä–≤ —Ñ–æ—Ä–º–∞—Ç, –æ–ø–∏—Å–∞–Ω –ø–æ-–¥–æ–ª—É. –ù–∞–ø–∏-
—à–µ—Ç–µ –ø—Ä–æ–≥—Ä–∞–º–∞, –∫–æ—è—Ç–æ –ø–æ –ø–æ–¥–∞–¥–µ–Ω–∞ –¥—É–º–∞ –∏–∑–ø–∏—Å–≤–∞ –Ω–µ–π–Ω–∞—Ç–∞ –¥–µ—Ñ–∏–Ω–∏—Ü–∏—è –Ω–∞ stdout (–∞–∫–æ –¥—É–º–∞—Ç–∞ —è –Ω—è–º–∞ –≤
—Ä–µ—á–Ω–∏–∫–∞, –∏–∑–≤–µ–∂–¥–∞ –ø–æ–¥—Ö–æ–¥—è—â–æ —Å—ä–æ–±—â–µ–Ω–∏–µ).

–ü—Ä–æ–≥—Ä–∞–º–∞—Ç–∞ –ø—Ä–∏–µ–º–∞ –¥–≤–∞ –∞—Ä–≥—É–º–µ–Ω—Ç–∞: —Ç—ä—Ä—Å–µ–Ω–∞ –¥—É–º–∞ –∏ —Ñ–∞–π–ª —Å —Ä–µ—á–Ω–∏–∫ (./main respect english.dic)
–†–µ—á–Ω–∏–∫—ä—Ç —Å–µ —Å—ä—Å—Ç–æ–∏ –æ—Ç –∑–∞–ø–∏—Å–∏, –∞ –≤—Å–µ–∫–∏ –∑–∞–ø–∏—Å —Å–µ —Å—ä—Å—Ç–æ–∏ –æ—Ç:
	‚Ä¢ –ù—É–ª–µ–≤ –±–∞–π—Ç
	‚Ä¢ –î—É–º–∞, –ø—Ä–µ–¥—Å—Ç–∞–≤–µ–Ω–∞ –∫–∞—Ç–æ –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª–Ω–æ—Å—Ç –æ—Ç –±–∞–π—Ç–æ–≤–µ (–º–µ–∂–¥—É 1 –∏ 63), –Ω–µ —Å—ä–¥—ä—Ä–∂–∞—â–∞ —Å–∏–º–≤–æ–ª–∏ –∑–∞ –Ω–æ–≤ —Ä–µ–¥ –∏ –Ω—É–ª–µ–≤–∏ –±–∞–π—Ç–æ–≤–µ
	‚Ä¢ –°–∏–º–≤–æ–ª –∑–∞ –Ω–æ–≤ —Ä–µ–¥
	‚Ä¢ –û–ø–∏—Å–∞–Ω–∏–µ –Ω–∞ –¥—É–º–∞—Ç–∞ (–ø—Ä–æ–∏–∑–≤–æ–ª–Ω–æ –¥—ä–ª–≥–∞ –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª–Ω–æ—Å—Ç –æ—Ç –±–∞–π—Ç–æ–≤–µ), –Ω–µ —Å—ä–¥—ä—Ä–∂–∞—â–æ –Ω—É–ª–µ–≤–∏ –±–∞–π—Ç–æ–≤–µ

–ó–∞–ø–∏—Å–∏—Ç–µ —Å–∞ —Å–æ—Ä—Ç–∏—Ä–∞–Ω–∏ –ª–µ–∫—Å–∏–∫–æ–≥—Ä–∞—Ñ—Å–∫–∏ –ø–æ –¥—É–º–∏—Ç–µ.
–¢–∞–∑–∏ –∑–∞–¥–∞—á–∞ –∏–∑–∏—Å–∫–≤–∞ —Ä–µ—à–µ–Ω–∏–µ, –ø—Ä–æ—á–∏—Ç–∞—â–æ –Ω–∞–π-–º–Ω–æ–≥–æ ùëÇ(ùëÄ log(ùëÅ )) –±–∞–π—Ç–∞ –æ—Ç —Ä–µ—á–Ω–∏–∫–∞, –∫—ä–¥–µ—Ç–æ ùëÅ –µ —Ä–∞–∑–º–µ—Ä—ä—Ç –Ω–∞ —Ä–µ—á–Ω–∏–∫–∞ –∞ ùëÄ –µ –º–∞–∫—Å–∏–º–∞–ª–Ω–∞—Ç–∞ –¥—ä–ª–∂–∏–Ω–∞ –Ω–∞ –∑–∞–ø–∏—Å. –†–µ—à–µ–Ω–∏—è —Å –ø–æ-–ª–æ—à–∞ —Å–ª–æ–∂–Ω–æ—Å—Ç —Å–µ –æ—Ü–µ–Ω—è–≤–∞—Ç —Å
–Ω–∞–π-–º–Ω–æ–≥–æ 8 —Ç–æ—á–∫–∏. (–ü–æ–¥—Å–∫–∞–∑–∫–∞: –¥–≤–æ–∏—á–Ω–æ —Ç—ä—Ä—Å–µ–Ω–µ.)
–ó–∞ —É–ª–µ—Å–Ω–µ–Ω–∏–µ, –ø—Ä–æ–≥—Ä–∞–º–∞—Ç–∞ –º–æ–∂–µ –¥–∞ –ø—Ä–∏–µ–º–µ –∫–∞—Ç–æ —Ç—Ä–µ—Ç–∏ –∞—Ä–≥—É–º–µ–Ω—Ç –∏–Ω–¥–µ–∫—Å–µ–Ω —Ñ–∞–π–ª, —Å—ä—Å—Ç–æ—è—â —Å–µ –æ—Ç 32-
–±–∏—Ç–æ–≤–∏ —á–∏—Å–ª–∞ –±–µ–∑ –∑–Ω–∞–∫ (./main respect english.dic english.idx). –¢–µ–∑–∏ —á–∏—Å–ª–∞ —Å–∞ –ø–æ–∑–∏—Ü–∏–∏—Ç–µ –Ω–∞ –≤—Å–∏—á–∫–∏ –Ω—É–ª–µ–≤–∏ –±–∞–π—Ç–æ–≤–µ –≤ —Ä–µ—á–Ω–∏–∫–∞. –ê–∫–æ –ø—Ä–æ–≥—Ä–∞–º–∞—Ç–∞ –≤–∏ —Ä–∞–±–æ—Ç–∏ –±–µ–∑ —Ç–æ–∑–∏ –∞—Ä–≥—É–º–µ–Ω—Ç, —â–µ –ø–æ–ª—É—á–∏—Ç–µ –±–æ–Ω—É—Å —Ç–æ—á–∫–∏.
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

#include <err.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdint.h>
#include <sys/stat.h>
#include <stdbool.h>
#include <string.h>

int open_safe(const char* file) {
    int fd = open(file, O_RDONLY);
    if(fd == -1) {err(2, "Could not open file %s!\n", file);}
    return fd;
}

off_t get_size(int fd, const char* file) {
    struct stat info;
    if(fstat(fd, &info) == -1) {err(3, "Could not stat file %s!\n", file);}
    return info.st_size;
}

void lseek_safe(int fd, const char* file, uint32_t position) {
    if (lseek(fd, position, SEEK_SET) == -1) {err(5, "Could not lseek file %s!\n", file);}
}

uint32_t get_null_pos(int fd, const char* file) {
    ssize_t read_bytes;
    uint32_t pos;
    if ((read_bytes = read(fd, &pos, sizeof(pos))) == -1) {err(6, "Could not read from file %s!\n", file);}
    if (read_bytes != sizeof(uint32_t)) {errx(7, "Could not read a whole position in file %s!\n", file);}
    return pos;
}

void read_word(char* current_word, int fd) {
    ssize_t read_bytes;
    char ch;
    int iter = 0;
    while((read_bytes = read(fd, &ch, sizeof(ch))) > 0) {
        if (ch == '\n') {
            current_word[iter] = '\0';
            break;
        }
        current_word[iter] = ch;
        iter++;
    }
    if (read_bytes == -1) {err(8, "Could not read from dictionery!\n");}
}

void get_meaning(int fd) {
    ssize_t read_bytes;
    char ch;
    while((read_bytes = read(fd, &ch, sizeof(ch))) > 0) {
        if (ch == '\0') {break;}
        if (write(1, &ch, sizeof(ch)) == -1) {err(9, "Could not write to stdout!\n");}
    }
    if (read_bytes == -1) {err(8, "Could not read from dictionery!\n");}
}

int main(int argc, char* argv[]) {
    if (argc != 4) {errx(1, "A word and two files expected!\n");}

    const char* word = argv[1];
    const char* dict = argv[2];
    const char* pos = argv[3];

    int fd_dict = open_safe(dict);
    int fd_pos = open_safe(pos);

    off_t dict_size = get_size(fd_dict, dict);
    off_t pos_size = get_size(fd_pos, pos);

    if (dict_size == 0) {errx(4, "File %s is empty!\n", dict);}
    if (pos_size % sizeof(uint32_t) != 0) {errx(5, "File %s must contain only uint32_t numbers!\n", pos);}

    uint32_t words_count = pos_size / sizeof(uint32_t);
    int rhs = words_count - 1;
    int lhs = 0;
    bool isFound = false;
    while(rhs >= lhs) {
        int midd = lhs + (rhs - lhs) / 2;
        uint32_t null_pos = get_null_pos(fd_pos, pos);
        lseek_safe(fd_dict, dict, null_pos + 1);
        char current_word[63];
        read_word(current_word, fd_dict);
        if (strcmp(current_word, word) == 0) {
            isFound = true;
            get_meaning(fd_dict);
            break;
        } else if(strcmp(current_word, word) > 0) {
            rhs = midd - 1;
        } else {
            lhs = midd + 1;
        }
    }

    close(fd_dict);
    close(fd_pos);
    if (isFound == false) {
        const char* message = "The searched word does not exist in the dictionery!\n";
        if (write(1, message, strlen(message)) == -1) {err(9, "Could not write message to stdout!\n");}
    }
    return 0;
}
