2020-SE-01
Напишете програма на C, която приема шест задължителни позиционни параметъра – имена на файлове.
 Примерно извикване:
$ ./main affix postfix prefix infix suffix crucifixus

Всички файлове започват с хедър с фиксирана дължина от 16 байта. Пети и шести (спрямо ℤ+) байт
от хедъра дефинират uint16_t число count, което описва броя на елементите във файла. Файловете
affix и infix се състоят от елементи от тип uint16_t, файловете prefix и crucifixus – от елементи
от тип uint8_t, postfix – от uint32_t, а suffix – от uint64_t.

Интервал наричаме наредена двойка числa, която дефинира номер (спрямо ℤ) на начален елемент
и брой елементи от даден файл. Комплект наричаме наредена четворка от интервали, които позиционно се отнасят спрямо файловете {post,pre,in,suf}fix.
Елементите на файлa affix дефинират серия от комплекти, на чиято база програмата трябва да генерира изходния файл crucifixus.
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

#include <err.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdint.h>
#include <stdbool.h>
#include <sys/stat.h>

typedef struct {
    uint16_t start;
    uint16_t count;
} interval_t;

typedef struct {
    interval_t post;
    interval_t pre;
    interval_t in;
    interval_t suf;
} set_t;

const int HEADER_SIZE = 16;
int open_safe(const char* file, bool isForRead);
int validate(const char* file, int size, uint16_t count, int* file_size);
uint16_t get_count(int fd, const char* file, int* file_size);
void avoid_header(int fd, const char* file);
void write_safe(interval_t interval, int fd_source, int fd_dest, int source_size, int bits);

void write_safe(interval_t interval, int fd_source, int fd_dest, int source_size, int bits) {
    uint16_t start = interval.start;
    uint16_t count = interval.count;
    if (bits == 32) {
        uint32_t el;
        off_t pos = lseek(fd_source, 16 + (start + count)*sizeof(uint32_t), SEEK_SET);
        if (pos == -1) {err(3, "Could not lseek!\n");}
        if (pos > source_size) {errx(6, "Invalid file content!\n");}
        if (lseek(fd_source, 16 + start * sizeof(uint32_t), SEEK_SET) == -1) {err(3, "Could not lseek!\n");}
        for(int i = 0; i < count; i++) {
            if (read(fd_source, &el, sizeof(el)) == -1) {err(4, "Problem reading!\n");}
            if (write(fd_dest, &el, sizeof(el)) == -1) {err(9, "Could not write!\n");}
        }
    } else if (bits == 8) {
        uint8_t el;
        off_t pos = lseek(fd_source, 16 + (start + count)*sizeof(uint8_t), SEEK_SET);
        if (pos == -1) {err(3, "Could not lseek!\n");}
        if (pos > source_size) {errx(6, "Invalid file content!\n");}
        if (lseek(fd_source, 16 + start * sizeof(uint8_t), SEEK_SET) == -1) {err(3, "Could not lseek!\n");}
        for(int i = 0; i < count; i++) {
            if (read(fd_source, &el, sizeof(el)) == -1) {err(4, "Problem reading!\n");}
            if (write(fd_dest, &el, sizeof(el)) == -1) {err(9, "Could not write!\n");}
        }
    } else if (bits == 16) {
        uint16_t el;
        off_t pos = lseek(fd_source, 16 + (start + count)*sizeof(uint16_t), SEEK_SET);
        if (pos == -1) {err(3, "Could not lseek!\n");}
        if (pos > source_size) {errx(6, "Invalid file content!\n");}
        if (lseek(fd_source, 16 + start * sizeof(uint16_t), SEEK_SET) == -1) {err(3, "Could not lseek!\n");}
        for(int i = 0; i < count; i++) {
            if (read(fd_source, &el, sizeof(el)) == -1) {err(4, "Problem reading!\n");}
            if (write(fd_dest, &el, sizeof(el)) == -1) {err(9, "Could not write!\n");}
        }
    } else if (bits == 64) {
        uint64_t el;
        off_t pos = lseek(fd_source, 16 + (start + count)*sizeof(uint64_t), SEEK_SET);
        if (pos == -1) {err(3, "Could not lseek!\n");}
        if (pos > source_size) {errx(6, "Invalid file content!\n");}
        if (lseek(fd_source, 16 + start * sizeof(uint64_t), SEEK_SET) == -1) {err(3, "Could not lseek!\n");}
        for(int i = 0; i < count; i++) {
            if (read(fd_source, &el, sizeof(el)) == -1) {err(4, "Problem reading!\n");}
            if (write(fd_dest, &el, sizeof(el)) == -1) {err(9, "Could not write!\n");}
        }
    }

}
void avoid_header(int fd, const char* file) {
    if (lseek(fd, HEADER_SIZE, SEEK_SET) == -1) {err(3, "Could not lseek file %s!\n", file);}
}

int open_safe(const char* file, bool isForRead) {
    int fd;
    if (isForRead == true) {
        fd = open(file, O_RDONLY);
    } else {
        fd = open(file, O_WRONLY | O_TRUNC | O_CREAT, 0666);
    }
    if (fd == -1) {err(2, "Could not open file %s!\n", file);}
    return fd;
}
uint16_t get_count(int fd, const char* file, int* file_size) {
    struct stat info;
    if (fstat(fd, &info) == -1) {err(5, "Could not stat file %s!\n", file);}
    if (info.st_size == 0) {errx(7, "Empty file %s!\n", file);}
    *file_size = info.st_size;

    uint16_t count;
    off_t count_pos = lseek(fd, 4, SEEK_SET);
    if (count_pos == -1) {err(3, "Could not lseek in file %s!\n", file);}
    if (read(fd, &count, sizeof(count)) == -1) {err(4, "Could not read elements count from file %s!\n", file);}
    return count;
}

int validate(const char* file, int size, uint16_t count, int* file_size) {
    if (size == 8) {
        if ((long unsigned int)*file_size != (count * sizeof(uint8_t) + 16)) {errx(6, "Invalid file content in %s!\n", file);}
    } else if (size == 16) {
        if ((long unsigned int)*file_size != (count * sizeof(uint16_t) + 16)) {errx(6, "Invalid file content in %s!\n", file);}
    } else if (size == 32) {
        if ((long unsigned int)*file_size != (count * sizeof(uint32_t) + 16)) {errx(6, "Invalid file content in %s!\n", file);}
    } else if (size == 64) {
        if ((long unsigned int)*file_size != (count * sizeof(uint64_t) + 16)) {errx(6, "Invalid file content in %s!\n", file);}
    }
    return *file_size;
}

int main(int argc, char* argv[]) {
        if (argc != 7) {errx(1, "Six files expected!\n");}

        const char* affix = argv[1];
        const char* postfix = argv[2];
        const char* prefix = argv[3];
        const char* infix = argv[4];
        const char* suffix = argv[5];
        const char* crucifixus = argv[6];

        int fd_aff = open_safe(affix, true);
        int fd_post = open_safe(postfix, true);
        int fd_pre = open_safe(prefix, true);
        int fd_in = open_safe(infix, true);
        int fd_suff = open_safe(suffix, true);
        int fd_cru = open_safe(crucifixus, false);

    int file_size = 0;
    int aff_size = validate(affix, 16, get_count(fd_aff, affix, &file_size), &file_size);
    int post_size = validate(postfix, 32, get_count(fd_post, postfix, &file_size), &file_size);
    int pre_size = validate(prefix, 8, get_count(fd_pre, prefix, &file_size), &file_size);
    int in_size = validate(infix, 16, get_count(fd_in, infix, &file_size), &file_size);
    int suff_size = validate(suffix, 64, get_count(fd_suff, suffix, &file_size), &file_size);

    set_t set;
    ssize_t read_bytes;
    avoid_header(fd_aff, affix);
    if ((aff_size - 16)  % sizeof(set) != 0) {errx(6, "Invalid file content in %s!\n", affix);}
    while((read_bytes = read(fd_aff, &set, sizeof(set))) == sizeof(set)) {
        write_safe(set.post, fd_post, fd_cru, post_size, 32);
        write_safe(set.pre, fd_pre, fd_cru, pre_size, 8);
        write_safe(set.in, fd_in, fd_cru, in_size, 16);
        write_safe(set.suf, fd_suff, fd_cru, suff_size, 64);
    }
    if (read_bytes == -1) {err(4, "Could not read from file %s!\n", affix);}
    if (read_bytes != 0 ) {errx(8, "Could not read a whole set from file %s!\n", affix);}

        close(fd_aff);
        close(fd_post);
        close(fd_pre);
        close(fd_in);
        close(fd_suff);
        close(fd_cru);
        return 0;
}
