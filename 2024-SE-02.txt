Зад. 104 2024-SE-02
Компресирането е начин да представим дадени данни, използвайки по-малко място от оригиналните
данни. Разглеждаме минимален алгоритъм за компресиране, който премахва повтарящите се байтове.

Напишете програма, която по подаден компресиран файл, възстановява оригиналния файл. 
Програмата приема два аргумента - име на компресиран файл и име на резултатен файл, в който да бъдат
записани оригиналните данни.
Компресираният файл започва с хедър, който има следния вид:
	• magic: 4 байта, представящи 32-битово число без знак, което винаги има стойността 0x21494D46
	и обозначава, че файлът следва това описание;
	• packet_count: 4 байта, представящи 32-битово число без знак – брой на пакетите в компресирания файл;
	• original_size: 8 байта, представящи 64-битово число без знак – размер на оригиналния файл,
	в байтове;
След хедъра има поредица от пакети, които описват какви данни трябва да има в резултатния файл.
Пакетите имат променлива дължина и винаги започват с един байт, който определя вида и размера
им. Този първи байт на пакет в двоична бройна система има вида: tsss ssss, където старшият бит
t определя вида на пакета (0 или 1), а останалите 7 бита образуват 8-битово число без знак от вида
0sss ssss, което ще наречем N.

Съществуват два вида пакети:
	• Пакетите от вид 0 наричаме обикновени пакети. Такъв пакет записва следващите N+1 байта от компресирания файл в резултатния файл.
	• Пакетите от вид 1 наричаме повтарящи се пакети. Такъв пакет записва следващия байт от компресирания файл N+1 пъти в резултатния файл.

Примери (всички числа са дадени в шестнайсетична бройна система):
• Пакетът 02 12 34 56 записва 12 34 56 в резултатния файл (този пакет е от вид 0 и за него N=2);
• Пакетът 84 78 записва 78 78 78 78 78 (вид 1, N=4);
• Трите пакета 00 13 82 37 01 73 33 записват 13 37 37 37 73 33
Програмата трябва да изчете пакетите от компресирания файл последователно и да запише тяхното
съдържание в резултатния файл, за да получи оригиналните данни.
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#include <err.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdbool.h>
#include <sys/stat.h>
#include <stdint.h>

typedef struct {
    uint32_t magic;
    uint32_t packet_count;
    uint64_t original_size;
} header_t;

int open_safe(const char* file, bool isToRead) {
    int fd;
    if (isToRead == true) {
        fd = open(file, O_RDONLY);
    } else {
        fd = open(file, O_WRONLY | O_TRUNC | O_CREAT, 0666);
    }
    if (fd == -1) {
        err(2, "Could not open file %s!\n", file);
    }
    return fd;
}

void validate_size(int fd, const char* file) {
    struct stat info;
    if(fstat(fd, &info) == -1) {err(3, "Could not stat file %s!\n", file);}
    if (info.st_size == 0) {errx(4, "Empty input file!\n");}
}

int main(int argc, char* argv[]) {
    if (argc != 3) {errx(1, "Two files expected!\n");}

    const char* input = argv[1];
    const char* output = argv[2];

    int fd_input = open_safe(input, true);
    int fd_output = open_safe(output, false);

    validate_size(fd_input, input);

    ssize_t read_bytes;
    header_t header;
    if ((read_bytes = read(fd_input, &header, sizeof(header))) == -1) {err(5, "Could not read properly from file %s!\n", input);}
    if (read_bytes != sizeof(header)) {errx(6, "Could not read a whole header!\n");}
    if (header.magic != 0x21494D46) {errx(7, "The input file does not follow the specification!\n");}

    uint8_t mask1 = 1 << 7;
    uint8_t mask2 = 0x7F;
    uint32_t i;
    for(i = 0; i < header.packet_count; i++) {
        uint8_t byte;
        if (read(fd_input, &byte, sizeof(byte)) == -1) {err(5, "Could not read properly from file %s!\n", input);}

        uint8_t type = byte & mask1;
        uint8_t N = byte & mask2;

        if (type == 0) {
            for(int j = 0; j < (N + 1); j++) {
                if (read(fd_input, &byte, sizeof(byte)) == -1) {err(5, "Could not read properly from file %s!\n", input);}
                if (write(fd_output, &byte, sizeof(byte)) == -1) {err(8, "Could not wtite properly to file %s!\n", output);}
            }
        }
        else if (type == 1) {
            if (read(fd_input, &byte, sizeof(byte)) == -1) {err(5, "Could not read properly from file %s!\n", input);}
            for(int j = 0; j < (N + 1); j++) {
                if (write(fd_output, &byte, sizeof(byte)) == -1) {err(8, "Could not wtite properly to file %s!\n", output);}
            }
        }
    }

    if (i != header.packet_count) {errx(9, "Inconsistent data in input file!\n");}

    close(fd_input);
    close(fd_output);
    return 0;
}
