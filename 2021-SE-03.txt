2021-SE-03
Напишете програма на C, която приема два позиционни параметъра – имена на файлове. Примерно извикване:
$ ./main input.bin output.h

Файлът input.bin е двоичен файл с елементи uint16_t числа, създаден на little-endian машина.
Вашата програма трябва да генерира C хедър файл, дефиниращ масив с име arr, който:
	• съдържа всички елементи от входния файл;
	• няма указана големина;
	• не позволява промяна на данните.
Генерираният хедър файл трябва да:
	• съдържа и uint32_t променлива arrN, която указва големината на масива;
	• бъде валиден и да може да се #include-ва без проблеми от C файлове, очакващи да “виждат” arr и arrN.
За да е валиден един входен файл, той трябва да съдържа не повече от 524288 елемента.
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

#include <err.h>
#include <stdint.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdbool.h>
#include <string.h>
#include <sys/stat.h>
#include <stdio.h>

int open_safe(const char* file, bool isForRead);
int open_safe(const char* file, bool isForRead) {
    int fd;
    if (isForRead == true) {
        fd = open(file, O_RDONLY);
    }
    else {
        fd = open(file, O_WRONLY | O_TRUNC | O_CREAT, 0666);
    }
    if (fd == -1) {err(2, "Could not open file %s!\n", file);}
    return fd;
}

uint32_t validate_input_file(int fd, const char* file);
uint32_t validate_input_file(int fd, const char* file) {
    const uint32_t MAX_COUNT =  524288;
    uint32_t count;
    struct stat info;
    if (fstat(fd, &info) == -1) {err(3, "Could not stat file %s!\n", file);}
    if ((info.st_size % (long int)sizeof(uint16_t)) != 0) {errx(4, "File %s must contain only uint16_t numbers!\n", file);}
    count = info.st_size / (long int)sizeof(uint16_t);
    if (count > MAX_COUNT) {errx(5, "File %s must not contain more than %d numbers!\n", file, MAX_COUNT);}
    return count;
}

void write_safe(const char* str, int fd);
void write_safe(const char* str, int fd) {
    ssize_t written_bytes;
    if ((written_bytes = write(fd, str, strlen(str))) == -1) {err(6, "Could not write to header file!\n");}
    if ((long unsigned int)written_bytes != strlen(str)) {errx(7, "Could not write the whole string to header file!\n");}
}

int main(int argc, char* argv[]) {
    if (argc != 3) {errx(1, "Two files expected!\n");}
    const char* input = argv[1];
    const char* output = argv[2];

    int fd_input = open_safe(input, true);
    int fd_output = open_safe(output, false);

    uint32_t el_count = validate_input_file(fd_input, input);

    const char* input_guard = "#pragma once\n";
    const char* header = "#include <stdint.h>\n\n";
    const char* first_part = "const uint16_t arr[] = {";
    const char* last_part = "};\n";
    const char* arrN = "const uint32_t arrN = ";

    write_safe(input_guard, fd_output);
    write_safe(header, fd_output);
    write_safe(first_part, fd_output);

    uint32_t count = 0;
    ssize_t read_bytes;
    uint16_t num;
    while((read_bytes = read(fd_input, &num, sizeof(num))) == sizeof(num)) {
        count++;
        char buff[20];
        if (count == el_count) {
            snprintf(buff, sizeof(buff), " %hu", num);
        } else {
            snprintf(buff, sizeof(buff), " %hu,", num);
        }
        write_safe(buff, fd_output);
    }
    if (read_bytes == -1) {err(8, "Could not read from file %s!\n", input);}
    if (read_bytes != 0) {errx(9, "Could not read a whole uint16_t number!\n");}

    write_safe(last_part, fd_output);
    char buffer[50];
    snprintf(buffer, sizeof(buffer), "%s%u;\n", arrN, el_count);
    write_safe(buffer, fd_output);

    close(fd_input);
    close(fd_output);
    return 0;
}
