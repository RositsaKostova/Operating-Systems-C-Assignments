Вашите колеги от съседната лаборатория са написали програма на C, която може да обработва подаден входен двоичен файл и на негова база генерира изходен двоичен файл.
Програмата работи като encoder, който имплементира вариант на Manchester code, т.е.:
	• за всеки входен бит 1 извежда битовете 10, и
	• за всеки входен бит 0 извежда битовете 01

Например следните 8 бита вход
1011 0110 == 0xB6
по описания алгоритъм дават следните 16 бита изход
1001 1010 0110 1001 == 0x9A69

Напишете програма на C, която извършва обратния процес, т.е., декодира файлове, създадени от горната програма.

Примерно извикване:
$ ./main input.bin output.bin
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#include <err.h>
#include <stdint.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdbool.h>
#include <sys/stat.h>

int open_safe(const char* file, bool isForRead);
int open_safe(const char* file, bool isForRead) {
    int fd;
    if (isForRead == true) {
        fd = open(file, O_RDONLY);
    }
    else {
        fd = open(file, O_WRONLY | O_TRUNC | O_CREAT, 0666);
    }
    if (fd == -1) {err(2, "Could not open file %s!\n", file);}
    return fd;
}

void write_safe(int fd, uint8_t result);
void write_safe(int fd, uint8_t result) {
    ssize_t written_bytes;
    if ((written_bytes = write(fd, &result, sizeof(result))) == -1) {err(6, "Could not write to output file!\n");}
    if ((long unsigned int)written_bytes != sizeof(result)) {errx(7, "Could not write the whole result to output file!\n");}
}

void set_result(uint16_t entry, int fd);
void set_result(uint16_t entry, int fd) {
    uint8_t result = 0;
    uint16_t entry_mask = 1 << 15;
    uint8_t result_mask = 1 << 7;
    for(int i = 0; i < 8; i++) {
        if ((entry & entry_mask) && !(entry & (entry_mask >> 1))) {
            result |= result_mask;
            result_mask = result_mask >> 1;
        } else if (!(entry & entry_mask) && (entry & (entry_mask >> 1))) {
            result_mask = result_mask >> 1;
        } else {
            errx(8, "Invalid input data!\n");
        }
        entry_mask = entry_mask >> 2;
    }
    write_safe(fd, result);
}

int main(int argc, char* argv[]) {
        if (argc != 3) {errx(1, "Two files expected!\n");}

        const char* input = argv[1];
        const char* output = argv[2];

        int fd_input = open_safe(input, true);
        int fd_output = open_safe(output, false);

    struct stat info;
    if (fstat(fd_input, &info) == -1) {err(10, "Could not stat file!\n");}
    if ((info.st_size % (long int)sizeof(uint16_t)) != 0) {errx(11, "Input file must contain only uint16_t numbers!\n");}

        uint16_t entry;
    ssize_t read_bytes;
    while((read_bytes = read(fd_input, &entry, sizeof(entry))) == sizeof(entry)) {
        set_result(entry, fd_output);
    }
    if (read_bytes == -1) {err(3, "Could not read properly from file %s!\n", input);}
    if (read_bytes != 0) {errx(9, "Could not read a whole entry!\n");}

    close(fd_input);
    close(fd_output);
    return 0;
}
