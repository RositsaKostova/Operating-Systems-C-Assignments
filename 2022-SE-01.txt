2022-SE-01
Напишете програма на C, която приема два позиционни аргумента – имена на двоични
файлове. Примерно извикване: ./main data.bin comparator.bin

Файлът data.bin се състои от две секции – 8 байтов хедър и данни. Структурата на хедъра е:
	• uint32_t, magic – магическа стойност 0x21796F4A, която дефинира, че файлът следва тази спецификация;
	• uint32_t, count – описва броя на елементите в секцията с данни.
Секцията за данни се състои от елементи – uint64_t числа.

Файлът comparator.bin се състои от две секции – 16 байтов хедър и данни. Структурата на хедъра е:
	• uint32_t, magic1 – магическа стойност 0xAFBC7A37;
	• uint16_t, magic2 – магическа стойност 0x1C27;
	• комбинацията от горните две magic числа дефинира, че файлът следва тази спецификация;
	• uint16_t, reserved – не се използва;
	• uint64_t, count – описва броя на елементите в секциата с данни.
Секцията за данни се състои от елементи – наредени 6-торки:
	• uint16_t, type – възможни стойности: 0 или 1;
	• 3 бр. uint16_t, reserved – възможни стойности за всяко: 0;
	• uint32_t, offset1;
	• uint32_t, offset2.

Двете числа offset дефинират отместване (спрямо ℕ0) в брой елементи за data.bin; type дефинира операция за сравнение:
	• 0: “по-малко”;
	• 1: “по-голямо”.
Елементите в comparator.bin дефинират правила от вида:
	• “елементът на offset1” трябва да е “по-малък” от “елементът на offset2”;
	• “елементът на offset1” трябва да е “по-голям” от “елементът на offset2”.
Програмата трябва да интепретира по ред дефинираните правила в comparator.bin и ако правилото не е изпълнено, да разменя in-place елементите на съответните отмествания. Елементи, които са
равни, няма нужда да се разменят.
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#include <err.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdint.h>
#include <stdbool.h>

typedef struct {
    uint32_t magic;
    uint32_t count;
} data_header_t;

typedef struct {
    uint32_t magic1;
    uint16_t magic2;
    uint16_t reserved;
    uint64_t count;
} comp_header_t;

typedef struct {
    uint16_t type;
    uint16_t res1;
    uint16_t res2;
    uint16_t res3;
    uint32_t offset1;
    uint32_t offset2;
} comp_entry_t;

int open_safe(const char* file, bool isOnlyRead);
int open_safe(const char* file, bool isOnlyRead) {
    int fd;
    if (isOnlyRead == true) {
        fd = open(file, O_RDONLY);
    } else {
        fd = open(file, O_RDWR);
    }
    if (fd == -1) {err(2, "Could not open file %s!\n", file);}
    return fd;
}

void lseek_safe(int fd, const char* file, uint32_t offset);
void lseek_safe(int fd, const char* file, uint32_t offset) {
    if (lseek(fd, sizeof(data_header_t) + offset * sizeof(uint64_t), SEEK_SET) == -1) {err(8, "Could not lseek in file %s!\n", file);}
}

void write_safe(int fd, const char* file, uint64_t el);
void write_safe(int fd, const char* file, uint64_t el) {
    if (write(fd, &el, sizeof(el)) == -1) {err(9, "Could not write properly to file %s!\n", file);}
}

void swap(int fd, const char* file, uint64_t first, uint64_t second, uint32_t offset1, uint32_t offset2);
void swap(int fd, const char* file, uint64_t first, uint64_t second, uint32_t offset1, uint32_t offset2) {
    lseek_safe(fd, file, offset1);
    write_safe(fd, file, second);
    lseek_safe(fd, file, offset2);
    write_safe(fd, file, first);
}

int main(int argc, char* argv[]) {
    if (argc != 3) {errx(1, "Two binary files expected!\n");}

    const uint32_t magic_data = 0x21796F4A;
    const uint32_t magic1_comp = 0xAFBC7A37;
    const uint16_t magic2_comp = 0x1C27;

    int data_fd = open_safe(argv[1], false);
    int comparator_fd = open_safe(argv[2], true);

    data_header_t header1;
    ssize_t read_bytes;
    if ((read_bytes = read(data_fd, &header1, sizeof(header1))) == -1) {err(3, "Could not read properly from file %s!\n", argv[1]);}
    if (read_bytes != (long int)sizeof(header1)) {errx(4, "Could not read the whole header of file %s!\n", argv[1]);}
    if (header1.magic != magic_data) {errx(5, "File %s does not follow its specification!\n", argv[1]);}
    if (header1.count == 0) {errx(6, "File %s does not contain any elements!\n", argv[1]);}

    comp_header_t header2;
    if ((read_bytes = read(comparator_fd, &header2, sizeof(header2))) == -1) {err(3, "Could not read properly from file %s!\n", argv[2]);}
    if (read_bytes != (long int)sizeof(header2)) {errx(4, "Could not read the whole header of file %s!\n", argv[2]);}
    if ((header2.magic1 != magic1_comp) || (header2.magic2 != magic2_comp)) {errx(5, "File %s does not follow its specification!\n", argv[2]);}
    if (header2.count == 0) {errx(6, "File %s does not contain any elements!\n", argv[2]);}

    comp_entry_t current;
    while((read_bytes = read(comparator_fd, &current, sizeof(current))) == sizeof(current)) {
        if (current.offset1 >= header1.count || current.offset2 >= header1.count) {
            errx(10, "Invalid offset in comparator file %s! Offsets %u or %u are out of range (max %u)\n", argv[2], current.offset1, current.offset2, header1.count - 1);
        }
        uint64_t first;
        uint64_t second;
        lseek_safe(data_fd, argv[1], current.offset1);
        if (read(data_fd, &first, sizeof(first)) == -1) {err(3, "Could not read properly from file %s!\n", argv[1]);}

        lseek_safe(data_fd, argv[1], current.offset2);
        if (read(data_fd, &second, sizeof(second)) == -1) {err(3, "Could not read properly from file %s!\n", argv[1]);}

        if (current.type == 0) {
            if (first > second) {
                swap(data_fd, argv[1], first, second, current.offset1, current.offset2);
            }
        } else if (current.type == 1) {
            if (first < second) {
                swap(data_fd, argv[1], first, second, current.offset1, current.offset2);
            }
        }
    }
    if (read_bytes == -1) {err(3, "Could not read properly from file %s!\n", argv[2]);}
    if (read_bytes != 0) {errx(7, "Could not read a whole entry from file %s!\n", argv[2]);}

    close(data_fd);
    close(comparator_fd);
    return 0;
}
