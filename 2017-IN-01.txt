2017-IN-01
Напишете програма на C, която използвайки външни shell команди през pipe() да извежда статистика за броя на използване на различните shell-ове от потребителите, дефинирани в системата.
 Изходът да бъде сортиран във възходящ ред според брой използвания на shell-овете.

Примерно извикване и изход:
$ ./main
1 /bin/sync
3 /bin/bash
7 /bin/false
17 /usr/sbin/nologin

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

#include <err.h>
#include <unistd.h>
#include <sys/wait.h>

int main(void) {
    pid_t pid;

    int cut_to_sort[2];
    if (pipe(cut_to_sort) == -1) {err(1, "Could not create a pipe between cut and sort!\n");}
    if ((pid = fork()) == -1) {err(2, "Parent could not create a child process!\n");}

    if (pid == 0) {
        close(cut_to_sort[0]);
        if (dup2(cut_to_sort[1], 1) == -1) {err(3, "Could not copy file descriptors!\n");}
        close(cut_to_sort[1]);

        execlp("cut", "cut", "-d:", "-f7", "/etc/passwd", (char*)NULL);
        err(4, "Child could not execute cut!\n");
    }

    close(cut_to_sort[1]);

    int sort_to_uniq[2];
    if (pipe(sort_to_uniq) == -1) {err(1, "Could not create a pipe between sort and uniq!\n");}
    if ((pid = fork()) == -1) {err(2, "Parent could not create a child process!\n");}

    if (pid == 0) {
        close(sort_to_uniq[0]);
        if(dup2(cut_to_sort[0], 0) == -1) {err(3, "Could not copy file descriptors!\n");}
        close(cut_to_sort[0]);

        if(dup2(sort_to_uniq[1], 1) == -1) {err(3, "Could not copy file descriptors!\n");}
        close(sort_to_uniq[1]);

        execlp("sort", "sort", (char*)NULL);
        err(5, "Child could not execute sort!\n");
    }

    close(cut_to_sort[0]);
    close(sort_to_uniq[1]);

    int uniq_to_sort[2];
    if (pipe(uniq_to_sort) == -1) {err(1, "Could not create a pipe between uniq and sort!\n");}
    if ((pid = fork()) == -1) {err(2, "Parent could not create a child process!\n");}

    if (pid == 0) {
        close(uniq_to_sort[0]);
        if(dup2(sort_to_uniq[0], 0) == -1) {err(3, "Could not copy file descriptors!\n");}
        close(sort_to_uniq[0]);

        if(dup2(uniq_to_sort[1], 1) == -1) {err(3, "Could not copy file descriptors!\n");}
        close(uniq_to_sort[1]);

        execlp("uniq", "uniq", "-c", (char*)NULL);
        err(6, "Child could not execute uniq!\n");
    }

    close(sort_to_uniq[0]);
    close(uniq_to_sort[1]);

    if ((pid = fork()) == -1) {err(2, "Parent could not create a child process!\n");}

    if (pid == 0) {
        if(dup2(uniq_to_sort[0], 0) == -1) {err(3, "Could not copy file descriptors!\n");}

        execlp("sort", "sort", "-n", (char*)NULL);
        err(7, "Child could not execute the last sort!\n");
    }

    close(uniq_to_sort[0]);

    for(int i = 0; i < 4; i++) {
        int status;
        if(wait(&status) == -1) {err(8, "Parent could not wait for child!\n");}

        if(!WIFEXITED(status)) {errx(9, "Task failed: child was killed!\n");}
        if(WEXITSTATUS(status) != 0) {err(10, "Task failed: exit status is not 0!\n");}
    }
        return 0;
}
